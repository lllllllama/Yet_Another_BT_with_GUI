# Yet-Another-BT BitTorrent å®¢æˆ·ç«¯é¡¹ç›®è¯¦ç»†åˆ†æ

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

**é¡¹ç›®åç§°**: Yet-Another-BT  
**é¡¹ç›®ç±»å‹**: å‘½ä»¤è¡Œ BitTorrent ä¸‹è½½å®¢æˆ·ç«¯  
**å¼€å‘è¯­è¨€**: C  
**ç›®æ ‡å¹³å°**: Linux / macOS  
**å¼€å‘æ—¶é—´**: 2013å¹´9æœˆ - 2025å¹´12æœˆï¼ˆæŒç»­å®Œå–„ï¼‰  
**ä»£ç æ¥æº**: åŸºäºã€ŠLinux Cç¼–ç¨‹å®æˆ˜ã€‹ä¸€ä¹¦çš„ä»£ç é‡æ„  

### é¡¹ç›®ç‰¹ç‚¹

- âœ… **çº¯Cè¯­è¨€å®ç°**ï¼šæ— ç¬¬ä¸‰æ–¹ä¾èµ–ï¼ˆé™¤OpenSSL/ncursesï¼‰
- âœ… **å®Œæ•´çš„BTåè®®**ï¼šå®ç°BTåè®®æ ¸å¿ƒåŠŸèƒ½
- âœ… **æ–­ç‚¹ç»­ä¼ **ï¼šæ”¯æŒä½å›¾æ¢å¤ä¸‹è½½è¿›åº¦
- âœ… **GUIç•Œé¢**ï¼šåŸºäºncursesçš„ç»ˆç«¯GUI
- âœ… **å¤šæ–‡ä»¶æ”¯æŒ**ï¼šæ”¯æŒå•æ–‡ä»¶å’Œå¤šæ–‡ä»¶ç§å­

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### 1. æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      main.c                             â”‚
â”‚                   (ç¨‹åºå…¥å£)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚          â”‚          â”‚
        â–¼          â–¼          â–¼          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Parse  â”‚ â”‚Tracker â”‚ â”‚ Peer   â”‚ â”‚ Data   â”‚
   â”‚Metafileâ”‚ â”‚        â”‚ â”‚Manager â”‚ â”‚Manager â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚          â”‚          â”‚          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
            â”‚             â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
        â”‚Messageâ”‚    â”‚Bitfieldâ”‚
        â”‚Handlerâ”‚    â”‚ & Hash â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ¨¡å—åŒ–è®¾è®¡

é¡¹ç›®é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œå…±åˆ†ä¸º **12ä¸ªæ ¸å¿ƒæ¨¡å—**ï¼š

| æ¨¡å— | æ–‡ä»¶ | åŠŸèƒ½ | ä»£ç è¡Œæ•° |
|------|------|------|----------|
| **1. ç§å­è§£æ** | parse_metafile.c/h | è§£æ.torrentç§å­æ–‡ä»¶ | 518 |
| **2. Trackeré€šä¿¡** | tracker.c/h | ä¸TrackeræœåŠ¡å™¨é€šä¿¡ | 476 |
| **3. Peerç®¡ç†** | peer.c/h | ç®¡ç†peerè¿æ¥å’ŒçŠ¶æ€ | 214 |
| **4. æ¶ˆæ¯å¤„ç†** | message.c/h | BTåè®®æ¶ˆæ¯ç¼–è§£ç  | 858 |
| **5. æ•°æ®ç®¡ç†** | data.c/h | ç¼“å­˜å’Œæ–‡ä»¶I/Oç®¡ç† | 1087 |
| **6. ä¸‹è½½ç­–ç•¥** | policy.c/h | pieceé€‰æ‹©å’Œpeerä¼˜åŒ– | 607 |
| **7. ä½å›¾æ“ä½œ** | bitfield.c/h | ä¸‹è½½è¿›åº¦ä½å›¾ç®¡ç† | 232 |
| **8. æ ¸å¿ƒæ§åˆ¶** | torrent.c/h | ä¸»ä¸‹è½½å¾ªç¯ | 479 |
| **9. å“ˆå¸Œè®¡ç®—** | bt_hash.c/h | SHA1å°è£… | 107 |
| **10. ä¿¡å·å¤„ç†** | signal_hander.c/h | ä¼˜é›…é€€å‡ºå¤„ç† | 50+ |
| **11. GUIç•Œé¢** | gui.c/h | ncursesç»ˆç«¯ç•Œé¢ | 200+ |
| **12. é”™è¯¯å¤„ç†** | bterror.c/h | é”™è¯¯ç å®šä¹‰ | 50+ |

---

## ğŸ“‚ è¯¦ç»†æ¨¡å—åˆ†æ

### æ¨¡å—1: ç§å­æ–‡ä»¶è§£æ (parse_metafile.c)

**æ ¸å¿ƒåŠŸèƒ½**: è§£æBTç§å­æ–‡ä»¶ï¼ˆBencodeç¼–ç ï¼‰

#### å…³é”®æ•°æ®ç»“æ„
```c
// ç§å­æ–‡ä»¶å…¨å±€å˜é‡
unsigned char  *metafile_content;    // ç§å­æ–‡ä»¶å†…å®¹
long long       metafile_length;     // ç§å­æ–‡ä»¶é•¿åº¦
int             pieces_length;       // pieceså­—æ®µé•¿åº¦
int             piece_length;        // å•ä¸ªpieceå¤§å°
unsigned char   info_hash[20];       // info_hashå€¼
unsigned char   peer_id[21];         // peer_id
char           *file_name;           // æ–‡ä»¶å
long long       file_length;         // æ–‡ä»¶é•¿åº¦
```

#### æ ¸å¿ƒå‡½æ•°ï¼ˆ15ä¸ªï¼‰

| å‡½æ•°å | åŠŸèƒ½ | å¤æ‚åº¦ |
|--------|------|--------|
| `read_metafile()` | è¯»å–ç§å­æ–‡ä»¶åˆ°å†…å­˜ | O(n) |
| `find_keyword()` | æŸ¥æ‰¾Bencodeå…³é”®å­— | O(n*m) |
| `read_announce_list()` | è§£ætracker URLåˆ—è¡¨ | O(n) |
| `get_piece_length()` | è·å–pieceé•¿åº¦ | O(n) |
| `get_pieces()` | è·å–pieceså“ˆå¸Œåˆ—è¡¨ | O(n) |
| `get_file_name()` | è·å–æ–‡ä»¶å | O(n) |
| `get_file_length()` | è·å–æ–‡ä»¶é•¿åº¦ | O(n) |
| `get_files_length_path()` | å¤šæ–‡ä»¶ä¿¡æ¯è·å– | O(n) |
| `get_info_hash()` | è®¡ç®—info_hash | O(n) |
| `get_peer_id()` | ç”Ÿæˆpeer_id | O(1) |

#### ç®—æ³•å®ç°

**Bencodeè§£æç¤ºä¾‹**ï¼š
```c
// Bencodeæ ¼å¼: d8:announce...e
// d = å­—å…¸å¼€å§‹, e = ç»“æŸ
// 8:announce = å­—ç¬¦ä¸²é•¿åº¦:å†…å®¹
int find_keyword(char *keyword, long *position) {
    long i, j;
    int keyword_len = strlen(keyword);
    
    // æš´åŠ›æœç´¢ - å¯ä¼˜åŒ–ä¸ºKMPç®—æ³•
    for(i = 0; i < metafile_length - keyword_len; i++) {
        for(j = 0; j < keyword_len; j++) {
            if(metafile_content[i+j] != keyword[j]) break;
        }
        if(j == keyword_len) {
            *position = i;
            return 0;
        }
    }
    return -1;
}
```

**Info Hashè®¡ç®—**ï¼š
```c
// info_hash = SHA1(infoå­—å…¸çš„å†…å®¹)
int get_info_hash() {
    long start, end;
    find_keyword("4:info", &start);
    // æ‰¾åˆ°infoå­—å…¸çš„èµ·æ­¢ä½ç½®
    // å¯¹è¯¥éƒ¨åˆ†è®¡ç®—SHA1
    compute_sha1(...);
}
```

---

### æ¨¡å—2: Trackeré€šä¿¡ (tracker.c)

**æ ¸å¿ƒåŠŸèƒ½**: ä¸TrackeræœåŠ¡å™¨äº¤äº’è·å–Peeråˆ—è¡¨

#### HTTPè¯·æ±‚æ„å»º

```c
int create_request(char *request, int len, Announce_list *node,
                   unsigned short port, long long down, 
                   long long up, long long left, int numwant)
{
    // æ„å»ºHTTP GETè¯·æ±‚
    // GET /announce?info_hash=%XX&peer_id=%XX&port=6881
    //     &uploaded=0&downloaded=0&left=1234567&compact=1
    
    char encoded_info_hash[61];
    char encoded_peer_id[61];
    
    http_encode(info_hash, 20, encoded_info_hash, 61);
    http_encode(peer_id, 20, encoded_peer_id, 61);
    
    sprintf(request, 
        "GET %s?info_hash=%s&peer_id=%s&port=%d"
        "&uploaded=%lld&downloaded=%lld&left=%lld&compact=1"
        "&numwant=%d HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Connection: close\r\n\r\n",
        path, encoded_info_hash, encoded_peer_id, port,
        up, down, left, numwant, host, port);
}
```

#### Trackerå“åº”è§£æ

**å“åº”æ ¼å¼ï¼ˆBencodeï¼‰**ï¼š
```
d8:completei5e10:incompletei2e8:intervali1800e
5:peers60:...binary peer info...e
```

**Peeråˆ—è¡¨è§£æ**ï¼š
```c
// Compactæ¨¡å¼: æ¯ä¸ªpeerå 6å­—èŠ‚
// [4å­—èŠ‚IP][2å­—èŠ‚ç«¯å£]
int parse_tracker_response2(char *buffer, int ret) {
    // æŸ¥æ‰¾ "5:peers"
    // åé¢ç´§è·Ÿé•¿åº¦å’ŒäºŒè¿›åˆ¶æ•°æ®
    // æ¯6å­—èŠ‚è§£æä¸€ä¸ªpeer
    for(i = 0; i < peer_count; i++) {
        unsigned char *p = &peers_info[i * 6];
        sprintf(ip, "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
        port = (p[4] << 8) | p[5];
        // æ·»åŠ åˆ°peeråˆ—è¡¨
    }
}
```

---

### æ¨¡å—3: Peerç®¡ç† (peer.c)

**æ ¸å¿ƒåŠŸèƒ½**: ç®¡ç†ä¸æ‰€æœ‰Peerçš„è¿æ¥

#### Peeræ•°æ®ç»“æ„

```c
typedef struct _Peer {
    // ç½‘ç»œè¿æ¥
    int            socket;          // socketæ–‡ä»¶æè¿°ç¬¦
    char           ip[16];          // IPåœ°å€
    unsigned short port;            // ç«¯å£å·
    char           id[21];          // peer_id
    
    // çŠ¶æ€æœº
    int            state;           // å½“å‰çŠ¶æ€
    
    // BTåè®®çŠ¶æ€
    int            am_choking;      // æˆ‘æ˜¯å¦é˜»å¡å¯¹æ–¹
    int            am_interested;   // æˆ‘æ˜¯å¦å¯¹å¯¹æ–¹æ„Ÿå…´è¶£
    int            peer_choking;    // å¯¹æ–¹æ˜¯å¦é˜»å¡æˆ‘
    int            peer_interested; // å¯¹æ–¹æ˜¯å¦å¯¹æˆ‘æ„Ÿå…´è¶£
    
    // ä½å›¾
    Bitmap         bitmap;          // peeræ‹¥æœ‰çš„pieces
    
    // æ¶ˆæ¯ç¼“å†²åŒº
    char           *in_buff;        // æ¥æ”¶ç¼“å†²åŒº
    int            buff_len;        // å·²æ¥æ”¶é•¿åº¦
    char           *out_msg;        // å‘é€ç¼“å†²åŒº
    int            msg_len;         // å¾…å‘é€é•¿åº¦
    
    // è¯·æ±‚é˜Ÿåˆ—
    Request_piece  *Request_piece_head;   // æˆ‘çš„è¯·æ±‚é˜Ÿåˆ—
    Request_piece  *Requested_piece_head; // å¯¹æ–¹çš„è¯·æ±‚é˜Ÿåˆ—
    
    // ç»Ÿè®¡ä¿¡æ¯
    unsigned int   down_total;      // ç´¯è®¡ä¸‹è½½é‡
    unsigned int   up_total;        // ç´¯è®¡ä¸Šä¼ é‡
    float          down_rate;       // ä¸‹è½½é€Ÿç‡
    float          up_rate;         // ä¸Šä¼ é€Ÿç‡
    
    struct _Peer   *next;           // é“¾è¡¨æŒ‡é’ˆ
} Peer;
```

#### PeerçŠ¶æ€æœº

```
INITIAL (-1) â†’ HALFSHAKED (0) â†’ HANDSHAKED (1)
    â†“              â†“                  â†“
  å¤±è´¥           æ¡æ‰‹              äº¤æ¢ä½å›¾
                               â†“
                          SENDBITFIELD (2)
                               â†“
                          RECVBITFIELD (3)
                               â†“
                           DATA (4) â† ä¸»è¦çŠ¶æ€
                               â†“
                          CLOSING (5)
```

---

### æ¨¡å—4: æ¶ˆæ¯å¤„ç† (message.c)

**æ ¸å¿ƒåŠŸèƒ½**: BitTorrentåè®®æ¶ˆæ¯ç¼–è§£ç 

#### BTåè®®æ¶ˆæ¯ç±»å‹

| ID | æ¶ˆæ¯ç±»å‹ | é•¿åº¦ | è¯´æ˜ |
|----|---------|------|------|
| - | keep-alive | 0 | ä¿æŒè¿æ¥ |
| 0 | choke | 1 | é˜»å¡å¯¹æ–¹ |
| 1 | unchoke | 1 | è§£é™¤é˜»å¡ |
| 2 | interested | 1 | è¡¨ç¤ºæ„Ÿå…´è¶£ |
| 3 | not interested | 1 | ä¸æ„Ÿå…´è¶£ |
| 4 | have | 5 | é€šçŸ¥æ‹¥æœ‰piece |
| 5 | bitfield | 1+X | å‘é€ä½å›¾ |
| 6 | request | 13 | è¯·æ±‚æ•°æ® |
| 7 | piece | 9+X | å‘é€æ•°æ® |
| 8 | cancel | 13 | å–æ¶ˆè¯·æ±‚ |

#### æ¶ˆæ¯æ ¼å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é•¿åº¦(4å­—èŠ‚)   â”‚ ID(1å­—èŠ‚)     â”‚ è´Ÿè½½(Nå­—èŠ‚)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å…³é”®æ¶ˆæ¯å®ç°

**Handshakeæ¶ˆæ¯**ï¼š
```c
int create_handshake_msg(char *info_hash, char *peer_id, Peer *peer) {
    // Handshakeæ ¼å¼:
    // [1å­—èŠ‚åè®®åé•¿åº¦][19å­—èŠ‚"BitTorrent protocol"]
    // [8å­—èŠ‚ä¿ç•™][20å­—èŠ‚info_hash][20å­—èŠ‚peer_id]
    
    peer->out_msg[0] = 19;
    memcpy(&peer->out_msg[1], "BitTorrent protocol", 19);
    memset(&peer->out_msg[20], 0, 8);  // ä¿ç•™å­—èŠ‚
    memcpy(&peer->out_msg[28], info_hash, 20);
    memcpy(&peer->out_msg[48], peer_id, 20);
    peer->msg_len = 68;
}
```

**Requestæ¶ˆæ¯**ï¼š
```c
int create_request_msg(int index, int begin, int length, Peer *peer) {
    // [é•¿åº¦:13][ID:6][index:4][begin:4][length:4]
    
    unsigned char c[4];
    int_to_char(13, c);
    memcpy(&peer->out_msg[peer->msg_len], c, 4);
    
    peer->out_msg[peer->msg_len + 4] = 6;  // REQUEST ID
    
    int_to_char(index, c);
    memcpy(&peer->out_msg[peer->msg_len + 5], c, 4);
    
    int_to_char(begin, c);
    memcpy(&peer->out_msg[peer->msg_len + 9], c, 4);
    
    int_to_char(length, c);
    memcpy(&peer->out_msg[peer->msg_len + 13], c, 4);
    
    peer->msg_len += 17;
}
```

**Pieceæ¶ˆæ¯å¤„ç†**ï¼š
```c
int process_piece_msg(Peer *peer, unsigned char *buff, int len) {
    // è§£æpieceæ¶ˆæ¯
    int index = char_to_int(&buff[5]);
    int begin = char_to_int(&buff[9]);
    int block_len = len - 9;
    
    // å†™å…¥ç¼“å­˜
    write_slice_to_btcache(index, begin, block_len, 
                          &buff[13], block_len, peer);
    
    // æ›´æ–°ç»Ÿè®¡
    peer->down_total += block_len;
    peer->down_count += block_len;
}
```

---

### æ¨¡å—5: æ•°æ®ç®¡ç† (data.c)

**æ ¸å¿ƒåŠŸèƒ½**: 16MBç¼“å­˜ç®¡ç†å’Œæ–‡ä»¶I/O

#### ç¼“å­˜ç­–ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         16MB ç¼“å­˜åŒº (Btcache)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¯ä¸ªèŠ‚ç‚¹ = 1ä¸ªSlice (16KB)              â”‚
â”‚  1024ä¸ªèŠ‚ç‚¹ Ã— 16KB = 16MB                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Btcacheæ•°æ®ç»“æ„

```c
typedef struct _Btcache {
    int            index;          // pieceç´¢å¼•
    int            begin;          // åœ¨pieceä¸­çš„åç§»
    int            length;         // sliceé•¿åº¦
    unsigned char  *buff;          // æ•°æ®ç¼“å†²åŒº
    
    unsigned char  is_full;        // æ˜¯å¦å·²å¡«å……æ•°æ®
    unsigned char  is_writed;      // æ˜¯å¦å·²å†™å…¥ç¡¬ç›˜
    unsigned char  read_write;     // 0=ä¸‹è½½ 1=ä¸Šä¼ 
    int            access_count;   // è®¿é—®è®¡æ•°
    
    struct _Btcache *next;
} Btcache;
```

#### ç¼“å­˜ç®¡ç†ç®—æ³•

**å†™å…¥æµç¨‹**ï¼š
```c
int write_slice_to_btcache(int index, int begin, int length,
                          unsigned char *buff, int len, Peer *peer)
{
    // 1. åœ¨ç¼“å­˜ä¸­æŸ¥æ‰¾å¯¹åº”çš„slice
    Btcache *p = btcache_head;
    while(p != NULL) {
        if(p->index == index && p->begin == begin) {
            // æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹
            if(!p->is_full) {
                memcpy(p->buff, buff, length);
                p->is_full = 1;
                
                // 2. æ£€æŸ¥æ˜¯å¦å®Œæˆä¸€ä¸ªpiece
                int sequence;
                if(is_a_complete_piece(index, &sequence)) {
                    // 3. éªŒè¯SHA1å“ˆå¸Œ
                    write_piece_to_harddisk(sequence, peer);
                }
                return 0;
            }
        }
        p = p->next;
    }
    
    // 4. å¦‚æœç¼“å­˜æ»¡äº†ï¼Œé‡Šæ”¾å·²å†™å…¥ç¡¬ç›˜çš„èŠ‚ç‚¹
    release_read_btcache_node(base_count);
}
```

**SHA1éªŒè¯**ï¼š
```c
int write_piece_to_harddisk(int sequence, Peer *peer) {
    // 1. ä»ç¼“å­˜æ”¶é›†ä¸€ä¸ªå®Œæ•´piece
    unsigned char *piece_buffer;
    read_piece_from_cache(sequence, piece_buffer);
    
    // 2. è®¡ç®—SHA1
    unsigned char digest[20];
    compute_sha1(piece_buffer, piece_length, digest);
    
    // 3. ä¸ç§å­æ–‡ä»¶ä¸­çš„å“ˆå¸Œå¯¹æ¯”
    if(memcmp(digest, &pieces[sequence * 20], 20) == 0) {
        // å“ˆå¸ŒåŒ¹é…ï¼Œå†™å…¥ç¡¬ç›˜
        write_to_file(piece_buffer);
        
        // 4. æ›´æ–°ä½å›¾
        set_bit_value(bitmap, sequence, 1);
        download_piece_num++;
        
        // 5. å‘æ‰€æœ‰peerå‘é€HAVEæ¶ˆæ¯
        prepare_send_have_msg();
    }
}
```

---

### æ¨¡å—6: ä¸‹è½½ç­–ç•¥ (policy.c)

**æ ¸å¿ƒåŠŸèƒ½**: Pieceé€‰æ‹©å’ŒPeerä¼˜åŒ–ç®—æ³•

#### ç­–ç•¥1: Chokingç®—æ³•

```c
// æ¯10ç§’æ‰§è¡Œä¸€æ¬¡
int select_unchoke_peer() {
    // 1. è®¡ç®—æ‰€æœ‰peerçš„ä¸‹è½½é€Ÿç‡
    compute_rate();
    
    // 2. é€‰æ‹©ä¸‹è½½é€Ÿç‡æœ€å¿«çš„4ä¸ªpeer
    Peer *fastest[4];
    for(int i = 0; i < 4; i++) {
        fastest[i] = find_fastest_peer(peer_head);
    }
    
    // 3. Unchokeè¿™4ä¸ªpeer
    for(int i = 0; i < 4; i++) {
        if(fastest[i]->am_choking) {
            create_chock_interested_msg(UNCHOKE, fastest[i]);
            fastest[i]->am_choking = 0;
        }
    }
    
    // 4. Chokeå…¶ä»–peer
    choke_other_peers(fastest);
}
```

#### ç­–ç•¥2: Optimistic Unchoking

```c
// æ¯30ç§’éšæœºé€‰æ‹©ä¸€ä¸ªè¢«chokeçš„peerè¿›è¡Œunchoke
int select_optunchoke_peer() {
    // éšæœºé€‰æ‹©ï¼Œç»™æ–°peeræœºä¼š
    Peer *random_peer = get_random_choked_peer();
    if(random_peer) {
        create_chock_interested_msg(UNCHOKE, random_peer);
        random_peer->am_choking = 0;
    }
}
```

#### ç­–ç•¥3: Pieceé€‰æ‹©ï¼ˆç¨€æœ‰ä¼˜å…ˆï¼‰

```c
int create_req_slice_msg(Peer *node) {
    // ç¨€æœ‰ç‰‡æ®µä¼˜å…ˆç®—æ³•
    // 1. ç»Ÿè®¡æ¯ä¸ªpieceåœ¨æ‰€æœ‰peerä¸­çš„å‡ºç°æ¬¡æ•°
    int piece_count[pieces_num];
    count_piece_frequency(piece_count);
    
    // 2. é€‰æ‹©æœ€ç¨€æœ‰ä¸”æœªä¸‹è½½çš„piece
    int rarest_piece = find_rarest_piece(piece_count, node);
    
    // 3. å°†pieceåˆ†å‰²ä¸º16KBçš„sliceå¹¶è¯·æ±‚
    for(int i = 0; i < slices_per_piece; i++) {
        create_request_msg(rarest_piece, i * 16384, 16384, node);
    }
}
```

---

### æ¨¡å—7: ä½å›¾æ“ä½œ (bitfield.c)

**æ ¸å¿ƒåŠŸèƒ½**: ä¸‹è½½è¿›åº¦çš„ä½å›¾è¡¨ç¤º

#### ä½å›¾ç»“æ„

```c
typedef struct _Bitmap {
    unsigned char *bitfield;        // ä½å›¾æ•°ç»„
    int           bitfield_length;  // ä½å›¾å­—èŠ‚æ•°
    int           valid_length;     // æœ‰æ•ˆä½æ•°
} Bitmap;
```

**ç¤ºä¾‹**ï¼š1000ä¸ªpieceséœ€è¦125å­—èŠ‚ï¼ˆ1000/8ï¼‰

```
Byte 0: [1][1][0][1][0][0][1][1]  = å·²ä¸‹è½½: 0, 1, 3, 6, 7
Byte 1: [0][0][1][1][0][1][0][0]  = å·²ä¸‹è½½: 10, 11, 13
...
```

#### ä½å›¾æ“ä½œ

**è·å–ä½å€¼**ï¼š
```c
int get_bit_value(Bitmap *bitmap, int index) {
    int byte_index = index / 8;         // å­—èŠ‚ç´¢å¼•
    int bit_offset = 7 - (index % 8);   // ä½åç§»
    
    return (bitmap->bitfield[byte_index] >> bit_offset) & 1;
}
```

**è®¾ç½®ä½å€¼**ï¼š
```c
int set_bit_value(Bitmap *bitmap, int index, unsigned char v) {
    int byte_index = index / 8;
    int bit_offset = 7 - (index % 8);
    
    v = v << bit_offset;
    bitmap->bitfield[byte_index] |= v;  // ä½¿ç”¨ORè¿ç®—
}
```

**æ–­ç‚¹ç»­ä¼ **ï¼š
```c
int create_bitfield() {
    char bitmapfile[128];
    sprintf(bitmapfile, "%d_bitmap", pieces_length);
    
    FILE *fp = fopen(bitmapfile, "rb");
    if(fp == NULL) {
        // æ–°ä¸‹è½½ï¼Œåˆå§‹åŒ–ä¸ºå…¨0
        memset(bitmap->bitfield, 0, bitmap->bitfield_length);
    } else {
        // æ¢å¤ä¹‹å‰çš„è¿›åº¦
        fread(bitmap->bitfield, 1, bitmap->bitfield_length, fp);
        download_piece_num = get_download_piece_num();
    }
}
```

---

### æ¨¡å—8: æ ¸å¿ƒæ§åˆ¶ (torrent.c)

**æ ¸å¿ƒåŠŸèƒ½**: ä¸»ä¸‹è½½å¾ªç¯å’Œäº‹ä»¶è°ƒåº¦

#### ä¸»å¾ªç¯æ¶æ„

```c
int download_upload_with_peers() {
    fd_set rset, wset;
    int max_sockfd;
    struct timeval timeout;
    
    while(1) {
        // 1. å‡†å¤‡socketé›†åˆ
        FD_ZERO(&rset);
        FD_ZERO(&wset);
        max_sockfd = 0;
        
        prepare_connect_tracker(&max_sockfd);  // Trackerè¿æ¥
        prepare_connect_peer(&max_sockfd);     // Peerè¿æ¥
        
        // 2. Selectå¤šè·¯å¤ç”¨
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        select(max_sockfd + 1, &rset, &wset, NULL, &timeout);
        
        // 3. å¤„ç†Trackerå“åº”
        process_tracker_response(&rset);
        
        // 4. å¤„ç†Peeræ¶ˆæ¯
        process_peer_messages(&rset, &wset);
        
        // 5. å®šæœŸä»»åŠ¡
        if(time(NULL) - last_time > 10) {
            select_unchoke_peer();      // Chokingç®—æ³•
            compute_rate();             // é€Ÿç‡è®¡ç®—
            print_process_info();       // è¿›åº¦æ˜¾ç¤º
            restore_bitmap();           // ä¿å­˜ä½å›¾
        }
        
        // 6. æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if(download_piece_num == pieces_length / 20) {
            printf("Download complete!\n");
            break;
        }
    }
}
```

#### äº‹ä»¶å¤„ç†

**Peerè¿æ¥å»ºç«‹**ï¼š
```c
int prepare_connect_peer(int *max_sockfd) {
    for(int i = 0; i < peer_count; i++) {
        if(peer_valid[i] == 0) {
            // åˆ›å»ºéé˜»å¡socket
            peer_sock[i] = socket(AF_INET, SOCK_STREAM, 0);
            fcntl(peer_sock[i], F_SETFL, O_NONBLOCK);
            
            // å‘èµ·è¿æ¥
            connect(peer_sock[i], &peer_addr[i], sizeof(struct sockaddr));
            
            // æ·»åŠ åˆ°peeré“¾è¡¨
            Peer *peer = add_peer_node();
            peer->socket = peer_sock[i];
            strcpy(peer->ip, inet_ntoa(peer_addr[i].sin_addr));
            peer->port = ntohs(peer_addr[i].sin_port);
            peer->state = INITIAL;
            
            peer_valid[i] = 1;
        }
    }
}
```

---

### æ¨¡å—9: GUIç•Œé¢ (gui.c)

**æ ¸å¿ƒåŠŸèƒ½**: åŸºäºncursesçš„ç»ˆç«¯ç•Œé¢

#### ç•Œé¢å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ttorrent ä¸‹è½½è¿›åº¦                      â”‚  â† æ ‡é¢˜æ 
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è¿›åº¦: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘] 65.4%               â”‚  â† è¿›åº¦æ¡
â”‚       (1234/1888 pieces)               â”‚
â”‚                                        â”‚
â”‚ ä¸‹è½½é€Ÿåº¦: 2.34 MB/s                    â”‚  â† ç»Ÿè®¡ä¿¡æ¯
â”‚ ä¸Šä¼ é€Ÿåº¦: 512 KB/s                     â”‚
â”‚ å·²ä¸‹è½½: 1.2 GB                         â”‚
â”‚                                        â”‚
â”‚ è¿æ¥çš„Peers: 15                        â”‚  â† Peerä¿¡æ¯
â”‚                                        â”‚
â”‚ [æŒ‰ Ctrl+C é€€å‡º]                       â”‚  â† æç¤ºä¿¡æ¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®ç°ä»£ç 

```c
void update_gui() {
    clear();  // æ¸…å±
    
    // 1. ç»˜åˆ¶æ ‡é¢˜
    attron(A_BOLD);
    mvprintw(1, 2, "ttorrent ä¸‹è½½è¿›åº¦");
    attroff(A_BOLD);
    
    // 2. ç»˜åˆ¶è¿›åº¦æ¡
    float progress = (float)download_piece_num / (pieces_length / 20);
    int bar_width = 40;
    int filled = (int)(progress * bar_width);
    
    mvprintw(3, 2, "è¿›åº¦: [");
    for(int i = 0; i < bar_width; i++) {
        if(i < filled) addch('â–ˆ');
        else addch('â–‘');
    }
    printw("] %.1f%%", progress * 100);
    
    // 3. ç»Ÿè®¡ä¿¡æ¯
    mvprintw(6, 2, "ä¸‹è½½é€Ÿåº¦: %.2f MB/s", total_down_rate / 1024 / 1024);
    mvprintw(7, 2, "ä¸Šä¼ é€Ÿåº¦: %.2f KB/s", total_up_rate / 1024);
    
    // 4. Peerä¿¡æ¯
    int peer_count = count_active_peers();
    mvprintw(9, 2, "è¿æ¥çš„Peers: %d", peer_count);
    
    refresh();  // åˆ·æ–°æ˜¾ç¤º
}
```

---

## ğŸ”„ å·¥ä½œæµç¨‹

### å®Œæ•´ä¸‹è½½æµç¨‹

```
1. å¯åŠ¨ç¨‹åº
   â””â”€> è§£æç§å­æ–‡ä»¶ (parse_metafile)
        â”œâ”€> è·å–tracker URL
        â”œâ”€> è·å–æ–‡ä»¶ä¿¡æ¯
        â”œâ”€> è®¡ç®—info_hash
        â””â”€> ç”Ÿæˆpeer_id

2. åˆå§‹åŒ–
   â””â”€> åˆ›å»ºä¸‹è½½æ–‡ä»¶ (create_files)
        â”œâ”€> åˆ†é…ç£ç›˜ç©ºé—´
        â””â”€> æ‰“å¼€æ–‡ä»¶æè¿°ç¬¦
   â””â”€> åˆ›å»ºä½å›¾ (create_bitfield)
        â”œâ”€> æ£€æŸ¥æ–­ç‚¹ç»­ä¼ 
        â””â”€> åˆå§‹åŒ–ä½å›¾
   â””â”€> åˆ›å»ºç¼“å­˜ (create_btcache)
        â””â”€> åˆ†é…16MBå†…å­˜

3. è¿æ¥Tracker
   â””â”€> å‘é€HTTP GETè¯·æ±‚
        â”œâ”€> info_hash
        â”œâ”€> peer_id
        â”œâ”€> port
        â””â”€> ç»Ÿè®¡ä¿¡æ¯
   â””â”€> è§£æå“åº”
        â”œâ”€> peeråˆ—è¡¨
        â”œâ”€> interval
        â””â”€> complete/incomplete

4. è¿æ¥Peers
   â””â”€> å¯¹æ¯ä¸ªpeer
        â”œâ”€> å»ºç«‹TCPè¿æ¥
        â”œâ”€> å‘é€handshake
        â”œâ”€> äº¤æ¢bitfield
        â””â”€> è¿›å…¥DATAçŠ¶æ€

5. ä¸‹è½½æ•°æ®
   â””â”€> ä¸»å¾ªç¯
        â”œâ”€> é€‰æ‹©piece (ç¨€æœ‰ä¼˜å…ˆ)
        â”œâ”€> å‘é€requestæ¶ˆæ¯
        â”œâ”€> æ¥æ”¶pieceæ¶ˆæ¯
        â”œâ”€> å†™å…¥ç¼“å­˜
        â”œâ”€> éªŒè¯SHA1
        â”œâ”€> å†™å…¥ç¡¬ç›˜
        â””â”€> å‘é€haveæ¶ˆæ¯

6. ç­–ç•¥è°ƒæ•´
   â””â”€> æ¯10ç§’
        â”œâ”€> è®¡ç®—peeré€Ÿç‡
        â”œâ”€> é€‰æ‹©unchokeçš„peer (Chokingç®—æ³•)
        â””â”€> éšæœºoptimistic unchoke
   â””â”€> æ¯30ç§’
        â””â”€> é‡æ–°è¿æ¥tracker

7. å®Œæˆ/é€€å‡º
   â””â”€> æ£€æµ‹ä¸‹è½½å®Œæˆ
   â””â”€> ä¿å­˜ä½å›¾
   â””â”€> å…³é—­è¿æ¥
   â””â”€> é‡Šæ”¾èµ„æº
```

---

## ğŸ“Š æ€§èƒ½ç‰¹æ€§

### 1. å†…å­˜ç®¡ç†

| ç»„ä»¶ | å¤§å° | è¯´æ˜ |
|------|------|------|
| 16MBç¼“å­˜ | 16,777,216 å­—èŠ‚ | ä¸»æ•°æ®ç¼“å†²åŒº |
| ç§å­æ–‡ä»¶ | å¯å˜ | å†…å­˜ä¸­ä¿å­˜ |
| Peerç»“æ„ | ~18KB/peer | åŒ…å«2ä¸ªMSG_SIZEç¼“å†²åŒº |
| ä½å›¾ | pieces/8 å­—èŠ‚ | ä¸‹è½½è¿›åº¦ |

### 2. ç½‘ç»œ I/O

- **éé˜»å¡I/O**: æ‰€æœ‰socketä½¿ç”¨O_NONBLOCK
- **Selectå¤šè·¯å¤ç”¨**: åŒæ—¶ç®¡ç†å¤šä¸ªè¿æ¥
- **ç¼“å†²æœºåˆ¶**: MSG_SIZE (18KB) ç¼“å†²åŒº

### 3. ç£ç›˜I/Oä¼˜åŒ–

- **é¢„åˆ†é…ç©ºé—´**: lseek + write
- **æ‰¹é‡å†™å…¥**: å®Œæ•´pieceéªŒè¯åä¸€æ¬¡æ€§å†™å…¥
- **ä½å›¾æŒä¹…åŒ–**: å®šæœŸä¿å­˜æ–­ç‚¹ä¿¡æ¯

---

## ğŸ› å·²çŸ¥é—®é¢˜ä¸æ”¹è¿›å»ºè®®

### å·²è¯†åˆ«çš„é—®é¢˜

#### 1. å†…å­˜å®‰å…¨é—®é¢˜
```c
// bitfield.c:121-123
void release_memory_in_bitfield() {
    if(bitmap->bitfield != NULL) free(bitmap->bitfield); // âš ï¸ æœªæ£€æŸ¥bitmap
    if(bitmap != NULL) free(bitmap);
}
```
**å»ºè®®**: å…ˆæ£€æŸ¥bitmapå†è®¿é—®æˆå‘˜

#### 2. ç¼–ç é—®é¢˜
- **ä½ç½®**: policy.c
- **ç°è±¡**: ä¸­æ–‡æ³¨é‡Šæ˜¾ç¤ºä¸ºä¹±ç 
- **åŸå› **: GBKç¼–ç 
- **å»ºè®®**: ç»Ÿä¸€ä½¿ç”¨UTF-8

#### 3. ç®—æ³•æ•ˆç‡
```c
// parse_metafile.c:68-83
int find_keyword(char *keyword, long *position) {
    // æš´åŠ›æœç´¢ O(n*m)
}
```
**å»ºè®®**: ä½¿ç”¨KMPæˆ–Boyer-Mooreç®—æ³•

#### 4. å‡½æ•°è¿‡é•¿
- **ä½ç½®**: data.c:674-794 (write_slice_to_btcache)
- **é—®é¢˜**: å•å‡½æ•°è¶…è¿‡120è¡Œ
- **å»ºè®®**: æ‹†åˆ†ä¸ºå­å‡½æ•°

### æ”¹è¿›æ–¹å‘

#### 1. åè®®æ‰©å±•
- [ ] æ”¯æŒDHT (å»ä¸­å¿ƒåŒ–)
- [ ] æ”¯æŒPEX (Peer Exchange)
- [ ] æ”¯æŒåŠ å¯† (MSE/PE)
- [ ] æ”¯æŒç£åŠ›é“¾æ¥

#### 2. æ€§èƒ½ä¼˜åŒ–
- [ ] å¤šçº¿ç¨‹ä¸‹è½½
- [ ] é›¶æ‹·è´I/O (sendfile)
- [ ] å†…å­˜æ± ç®¡ç†
- [ ] æ›´æ™ºèƒ½çš„pieceé€‰æ‹©ç®—æ³•

#### 3. ç”¨æˆ·ä½“éªŒ
- [ ] Webç•Œé¢
- [ ] é…ç½®æ–‡ä»¶æ”¯æŒ
- [ ] é™é€ŸåŠŸèƒ½
- [ ] ä¸‹è½½é˜Ÿåˆ—ç®¡ç†

#### 4. å¯é æ€§
- [ ] å®Œå–„çš„é”™è¯¯å¤„ç†
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–
- [ ] å†…å­˜æ³„æ¼æ£€æµ‹
- [ ] å‹åŠ›æµ‹è¯•

---

## ğŸ“ˆ æµ‹è¯•ä¸éªŒè¯

### å½“å‰æµ‹è¯•è¦†ç›–

å·²åˆ›å»ºçš„æµ‹è¯•æ–‡ä»¶: `test_main.c`

| æµ‹è¯•å‡½æ•° | è¦†ç›–æ¨¡å— | çŠ¶æ€ |
|----------|---------|------|
| `test_int_char_conversion` | message.c | âœ… å·²å®ç° |
| `test_bit_operations` | bitfield.c | âœ… å·²å®ç° |
| `test_is_interested` | bitfield.c | âœ… å·²å®ç° |
| `test_find_keyword` | parse_metafile.c | âœ… å·²å®ç° |
| `test_message_parsing` | message.c | âœ… å·²å®ç° |
| `test_bt_hash_concept` | bt_hash.c | âœ… å·²å®ç° |
| `test_buffer_safety` | data.c | âœ… å·²å®ç° |

### å»ºè®®çš„æµ‹è¯•åœºæ™¯

1. **åŠŸèƒ½æµ‹è¯•**
   - å•æ–‡ä»¶ç§å­ä¸‹è½½
   - å¤šæ–‡ä»¶ç§å­ä¸‹è½½
   - æ–­ç‚¹ç»­ä¼ 
   - å¤§æ–‡ä»¶ä¸‹è½½ (>4GB)

2. **å‹åŠ›æµ‹è¯•**
   - 100+ peersåŒæ—¶è¿æ¥
   - 1000+ piecesçš„å¤§æ–‡ä»¶
   - ç½‘ç»œæŠ–åŠ¨åœºæ™¯
   - ç£ç›˜æ»¡åœºæ™¯

3. **å…¼å®¹æ€§æµ‹è¯•**
   - ä¸å…¶ä»–BTå®¢æˆ·ç«¯äº’æ“ä½œ
   - ä¸åŒTrackeræœåŠ¡å™¨
   - ä¸åŒç§å­æ ¼å¼

---

## ğŸ“š æŠ€æœ¯æ ˆæ€»ç»“

### ç¼–ç¨‹è¯­è¨€ä¸æ ‡å‡†
- **è¯­è¨€**: C (C99)
- **ç¼–è¯‘å™¨**: GCC 4.0+

### ç³»ç»ŸAPI
- **ç½‘ç»œ**: BSD Socket API
- **I/O**: POSIX (open, read, write, lseek)
- **å¹¶å‘**: selectå¤šè·¯å¤ç”¨
- **ä¿¡å·**: signalå¤„ç†

### ç¬¬ä¸‰æ–¹åº“
- **OpenSSL**: SHA1å“ˆå¸Œè®¡ç®—
- **ncurses**: ç»ˆç«¯GUIç•Œé¢

### åè®®æ ‡å‡†
- **BitTorrent**: BEP 003 (åŸºç¡€åè®®)
- **HTTP**: Trackeré€šä¿¡
- **Bencode**: æ•°æ®ç¼–ç 

---

## ğŸ“ å­¦ä¹ ä»·å€¼

è¿™ä¸ªé¡¹ç›®éå¸¸é€‚åˆå­¦ä¹ ä»¥ä¸‹å†…å®¹ï¼š

### 1. ç³»ç»Ÿç¼–ç¨‹
- Socketç½‘ç»œç¼–ç¨‹
- éé˜»å¡I/O
- Selectå¤šè·¯å¤ç”¨
- æ–‡ä»¶I/Oæ“ä½œ
- ä¿¡å·å¤„ç†

### 2. æ•°æ®ç»“æ„ä¸ç®—æ³•
- ä½å›¾æ“ä½œ
- é“¾è¡¨ç®¡ç†
- å“ˆå¸Œç®—æ³• (SHA1)
- å­—ç¬¦ä¸²åŒ¹é…
- Bencodeç¼–è§£ç 

### 3. åè®®å®ç°
- BitTorrentåè®®
- HTTPåè®®
- çŠ¶æ€æœºè®¾è®¡
- æ¶ˆæ¯é˜Ÿåˆ—

### 4. è½¯ä»¶å·¥ç¨‹
- æ¨¡å—åŒ–è®¾è®¡
- é”™è¯¯å¤„ç†
- å†…å­˜ç®¡ç†
- ä»£ç å¤ç”¨

---

## ğŸ“– å‚è€ƒèµ„æ–™

1. **BitTorrentåè®®**
   - [BEP 003: The BitTorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html)
   - [BEP 020: Peer ID Conventions](https://www.bittorrent.org/beps/bep_0020.html)

2. **æŠ€æœ¯æ–‡æ¡£**
   - [Bencodeç¼–ç ](https://en.wikipedia.org/wiki/Bencode)
   - [POSIX APIå‚è€ƒ](https://pubs.opengroup.org/onlinepubs/9699919799/)

3. **ä¹¦ç±**
   - ã€ŠLinux Cç¼–ç¨‹å®æˆ˜ã€‹(åŸå§‹ä»£ç æ¥æº)
   - ã€ŠUNIXç½‘ç»œç¼–ç¨‹ å·1ã€‹

4. **é¡¹ç›®æ–‡æ¡£**
   - `USAGE.md` - ä½¿ç”¨æ–‡æ¡£
   - `GUI_USAGE.md` - GUIä½¿ç”¨è¯´æ˜
   - `log.md` - å¼€å‘æ—¥å¿—

---

## âš–ï¸ è®¸å¯ä¸ç‰ˆæƒ

- åŸå§‹ä»£ç æ¥æº: ã€ŠLinux Cç¼–ç¨‹å®æˆ˜ã€‹
- é¡¹ç›®é‡æ„: 2013å¹´
- æŒç»­å®Œå–„: 2025å¹´

---

**åˆ†æå®Œæˆæ—¶é—´**: 2025-12-24  
**åˆ†æè€…**: Gemini AI Assistant  
**é¡¹ç›®ç‰ˆæœ¬**: v1.0 (with GUI)
